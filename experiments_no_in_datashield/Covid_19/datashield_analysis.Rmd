---
title: "Ranking using DataShield"
output: html_notebook
---

# Libraries and global variables
```{r}
library(DSI)
library(DSOpal)
library(dsBaseClient)
library(dsConnectClient)
library(dsShareClient)
source("tools_datashield.R")
IN_SCRIPT      <- TRUE
SERVERS_SYMBOL <- "D"
```


# Building login data frame and login
```{R}
source("datashield_login_info.R")
```
Login data details:
```{r}
login_data
```

Connections details:
```{r}
connections
```       
# Explore the data on the servers
## List of R objects on each servers
```{R}
dsBaseClient::ds.ls(datasources = connections)
```
_Dimensions:_
```{r}
ds.dim(x="D", type = "both", datasources = connections)
```



**Summary:**
```{r}
ds.summary(x = "D", datasources = connections)
```

# Statistics
_Centrality:_
```{r}
ds.mean(x = "D$confirmed", type = "both", datasources = connections)
```
_Quantiles_:
```{r}
ds.quantileMean(x='D$confirmed', type = "split", datasources = connections)
```

```{r}
ds.quantileMean(x='D$confirmed', type = "combine", datasources = connections)
```
**Skewness:**
https://en.wikipedia.org/wiki/File:Relationship_between_mean_and_median_under_different_skewness.png

```{r}
ds.skewness(x = "D$confirmed",
              method = 1, 
              type = "both",
             datasources = connections)
```



# Homologuous encryption
## Prepare for encryption - assign values to servers and client

```{r}
assignNonParamSettings(x = "D$confirmed", data.encrypted = "data.encrypted", datasources = connections)
```

# client side variables
```{r}
ls(pattern =".non.param.setting", all.names = TRUE)
```

_Name of servers variables created on the servers_:
```{r}
.non.param.setting
```

# server-side 
**New R object settings_non_param**
```{r}
dsBaseClient::ds.ls(datasources = connections)
```

## Assign values to variables required for sharing 
```{r}
dsShareClient::ds.assign.sharing.settings(datasources = connections)
```

```{r}
dsBaseClient::ds.ls(datasources = connections)
```
## share the parameters using a matrix base homologuous encryption
vectors dot-products and matrices multiplication are used to share parameters using a series of shared-secrets. Communication between two servers and passing through an analysis computers occurs. Each time two servers starts the exchange of private and share secrets, new random encrypting values are used. 
```{r}
# retrieve names of the params stored on the server
param.names <- .non.param.setting
param.names <- unlist(param.names)
Sys.time()
dsShareClient::ds.share.param(param.names = param.names, datasources = connections)    
```

```{r}
Sys.time()
dsBaseClient::ds.ls(datasources = connections)
```
```{r}
occult(datasources = connections)
```

```{r}
dsBaseClient::ds.ls(datasources = connections)
ds.summary(x = "sharing", datasources = connections)
```
```{r}
ls(all.names = TRUE)
```

```{r}
.non.param.setting
```

```{r}
client.compute.bin(datasources = connections)
```

```{r}
ls(all.names = TRUE)
```

```{r}
.bins.definition
```
```{r}
source("tools_datashield.R")
compute.rank(datasources = connections)
```
```{r}
ls(all.names = TRUE)
```
```{r}
.ranks
```

# Logout
```{r}
ds.logout()
rm(list= ls())
```
